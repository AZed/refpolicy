<h1>Getting Started</h1>
<p>
This guide will walk you through the basics of creating a new reference policy module. This will also serve as an introduction to the basics concepts and philosophy of refpolicy.
To install and use a targeted Reference Policy on a Fedora Core 4 system, see the
<a href="index.php?page=switch">switching guide</a>.
</p>
<h2>Creating A Module</h2>
<p>
Modules are the principal organizing component in refpolicy. They are conceptually similar to the source modules in the current strict and targeted policy, but have additional meaning. A module contains the policy for an application or related group of applications, private and shared resources, labeling information, and interfaces that allow other modules access to the modules resources. The majority of the global policy has been eliminated in refpolicy. Certain policy components, like users and object classes, are still global in refpolicy, but almost all TE policy is now contained within a module. 
</p>
<p>
Modules should be placed in refpolicy/policy/LAYER, where LAYER is the name of the appropriate layer. The current layers can be seen in the <A href="api-docs/">interface documentation</A>. Let's create a new module in the services layer called myapp. This is done by creating three files: myapp.te, mayapp.fc, and myapp.if, all in directory refpolicy/policy/services. The file myapp.te file will contain all of the policy private to this module, including any types or attributes. The file myapp.fc file will contain the file context labeling statement for this module. Finally, the file myapp.if will contain the interfaces for this module (interfaces will be explained below).
</p>
<h3>Module TE Policy</h3>
<p>
First create myapp.te and add the following:
<div id="codeblock">
<pre>
# Private type declarations
type myapp_t;
type myapp_exec_t;
type myapp_log_t;
type myapp_tmp_t;

domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t)
logging_log_file(myapp_log_t)
files_tmp_file(myapp_tmp_t)
</pre>
</div>
</p>
<p>
This creates all of the types needed for this module, including a type for the process, executables, log files, and temporary files. The first thing to notice is that there are no attributes applied to any of these types. In refpolicy all types and attributes can only be referred to in the module that declares them. This means that it is not possible, for example, to directly refer to the domain attribute. Instead, macros in other modules are used to declare that a type will be used for a certain purpose. These macros will likely use attributes (but not necessarily), but it allows the module that declared the attribute to strictly control how it can be used. In this example interfaces are used to transform the types into a domain, entry file, log file, and temporary file.
</p>
<p>
Let's expand this example further by allowing some access for these types. My application needs access between it's own types and access to read random numbers. The access between private types is written exactly the same way current policy rules are written, i.e.:
<div id="codeblock">
<pre>
allow myapp_t myapp_log_t:file ra_file_perms;
allow myapp_t myapp_tmp_t:file create_file_perms;
</pre>
</div>
<p>This allows myapp_t to write to it's private types, but it needs to be able to
create its temporary files in /tmp.  This requires a call to the files module.</p>
<div id="codeblock">
<pre>
files_create_tmp_files(myapp_t,myapp_tmp_t,file)
</pre>
</div>
<p>
This call to the files module allows myapp_t to create myapp_tmp_t files in
the /tmp directory.
</p>
<h3>Module IF Policy</h3>
<p>
The interface file creates the macros that other modules will use to gain access
to my resources. This allows the module that created the type or attribute to
define appropriate uses. Additionally, it provides a single point for
documentation. Create myapp.if and add the following:
<div id="codeblock">
<pre>
## &lt;summary&gt;Myapp example policy&lt;/summary&gt;
## &lt;desc&gt;
##	&lt;p&gt;
##		More descriptive text about myapp.  The &lt;desc&gt;
##		tag can also use &lt;p&gt;, &lt;ul&gt;, and &lt;ol&gt;
##		html tags for formatting.
##	&lt;/p&gt;
##	&lt;p&gt;
##		This policy supports the following myapp features:
##		&lt;ul&gt;
##		&lt;li&gt;Feature A&lt;/li&gt;
##		&lt;li&gt;Feature B&lt;/li&gt;
##		&lt;li&gt;Feature C&lt;/li&gt;
##		&lt;/ul&gt;
##	&lt;/p&gt;
## &lt;/desc&gt;

## &lt;summary&gt;
##	Execute a domain transition to run myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##	Domain allowed to transition.
## &lt;/param&gt;
interface(`myapp_domtrans',`
	gen_requires(`
		type myapp_t, myapp_exec_t;
		class fd use;
		class process sigchld;
		class fifo_file rw_file_perms;
	')

	domain_auto_trans($1,myapp_exec_t,myapp_t)

	allow $1 myapp_t:fd use;
	allow myapp_t $1:fd use;
	allow $1 myapp_t:fifo_file rw_file_perms;
	allow $1 myapp_t:process sigchld;
')

## &lt;summary&gt;
##	Read myapp log files.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##	Domain allowed to read the log files.
## &lt;/param&gt;
interface(`myapp_read_log',`
	gen_requires(`
		type myapp_log_t;
		class file r_file_perms;
	')

	logging_search_logs($1)
	allow $1 myapp_log_t:file r_file_perms;
')
</pre>
</div>
<p>
The first interface allows other domains to do a domain
transition to myapp_t, by executing a program labeled myapp_exec_t.
</p>
<p>
The second interface allows other domains to read myapp's log files.  Myapp's
log files are in the /var/log directory, so the access to search the /var/log
directory is also given by the interface.  The gen_requires() macro is used to
support loadable policy modules, and must explicitly list the type, attributes,
object classes, and permissions used by this interface.
</p>
